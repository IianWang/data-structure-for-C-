# 第七章 
## 7.3 链表处理
### 7.3.1 链表的概念
### 7.3.2 使用malloc函数或new运算符为链表结点分配内存空间
### 7.3.3 链表的基本操作
- 创建链表
- 查找元素
```C++
void insert_ele(node *head, int pos, int x){
    node* p = head;//直接从首元结点开始循环
    for (int i = 0; i < pos - 1; i++) {
        p = p -> next;
    }
    node* now = new node;
    now -> data = x;
    now -> next = p -> next;
    p -> next = now;
}
```
- 插入元素
```C++
void insert_ele(node *head, int pos, int x){
    node* p = head;//直接从首元结点开始循环
    for (int i = 0; i < pos - 1; i++) {
        p = p -> next;
    }
    node* now = new node;
    now -> data = x;
    now -> next = p -> next;
    p -> next = now;
}
```
- 删除元素
```C++
void delet_ele(node *head, int x){
    //对链表来说删除元素是指删掉链表上所有的与给定值相等的元素
    node* p = head -> next;
    node* pre = head;
    while (p) {
        if (p -> data == x) {
            pre -> next = p -> next;
            delete(p);
            p = pre -> next;
        }
        else{
            pre = p;
            p = p -> next;
        }
    }
}
```
### 7.3.4 静态链表
静态链表运用hash原理，结点内存地址是比较小的整数，用起来比较方便，而且不需要头结点
```C++
struct Node{
    int data;
    int next;
}node[10010];
```

PAT
```C++
//1074 Reversing Linked List (25 分)
//不定向步长反转链表
//这道题我个人是用栈+链表来处理，觉得很麻烦，且用书上的
//
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 101000

using namespace std;
struct Node{
    int data;
    int next;
    int address;
    int order;
}node[maxn];

bool cmp(Node a, Node b){
    return a.order < b.order;
}

int main(){
    for (int i = 0; i < maxn; i++) {
        node[i].order = maxn;
    }
    
    int begin, n, K, address;
    scanf("%d %d %d", &begin, &n, &K);
    for (int i = 0; i < n; i++) {
        scanf("%d", &address);
        scanf("%d %d", &node[address].data, &node[address].next);
        node[address].address = address;
    }
    
    int p = begin, count = 0;//count计数有效结点的数目
    while (p != -1) {
        node[p].order = count++;
        p = node[p].next;
    }
    sort(node, node + maxn, cmp);
    n = count;
    for (int i = 0; i < n / K; i++) {
        for (int j = (i + 1) * K - 1; j > i * K; j--) {
            printf("%05d %d %05d", node[j].address, node[j].data, node[j - 1].address);
        }
        //每一步的最后一块都要单独处理
        printf("%05d %d ", node[i * K].address, node[i].data);
        if (i < n / K - 1) {
            printf("%05d\n", node[(i + 2) * K - 1].address);
        }
        else{
            if(n % K == 0) printf("-1\n");
            else{
                printf("%05d\n", node[(i + 1) * K].address);
                for (int i = n / K * K; i < n; i++) {
                    printf("%05d %d ", node[i].address, node[i].data);
                    if (i < n - 1) {
                        printf("%05d\n", node[i + 1].address);
                    }
                    else printf("-1\n");
                }
            }
        }
    }
    
    
    return 0;
};
```
