# 第七章 
## 7.3 链表处理
### 7.3.1 链表的概念
### 7.3.2 使用malloc函数或new运算符为链表结点分配内存空间
### 7.3.3 链表的基本操作
- 创建链表
- 查找元素
```C++
void insert_ele(node *head, int pos, int x){
    node* p = head;//直接从首元结点开始循环
    for (int i = 0; i < pos - 1; i++) {
        p = p -> next;
    }
    node* now = new node;
    now -> data = x;
    now -> next = p -> next;
    p -> next = now;
}
```
- 插入元素
```C++
void insert_ele(node *head, int pos, int x){
    node* p = head;//直接从首元结点开始循环
    for (int i = 0; i < pos - 1; i++) {
        p = p -> next;
    }
    node* now = new node;
    now -> data = x;
    now -> next = p -> next;
    p -> next = now;
}
```
- 删除元素
```C++
void delet_ele(node *head, int x){
    //对链表来说删除元素是指删掉链表上所有的与给定值相等的元素
    node* p = head -> next;
    node* pre = head;
    while (p) {
        if (p -> data == x) {
            pre -> next = p -> next;
            delete(p);
            p = pre -> next;
        }
        else{
            pre = p;
            p = p -> next;
        }
    }
}
```
### 7.3.4 静态链表
静态链表运用hash原理，结点内存地址是比较小的整数，用起来比较方便，而且不需要头结点
```C++
struct Node{
    int data;
    int next;
}node[10010];
```

PAT
```C++
//1074 Reversing Linked List (25 分)
//不定向步长反转链表
//这道题我个人是用栈+链表来处理，觉得很麻烦，且用书上的
//书上的看起来也有些繁琐，没办法菜就多做题
//复习！
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 101000

using namespace std;
struct Node{
    int data;
    int next;
    int address;
    int order;
}node[maxn];

bool cmp(Node a, Node b){
    return a.order < b.order;
}

int main(){
    for (int i = 0; i < maxn; i++) {
        node[i].order = maxn;
    }
    
    int begin, n, K, address;
    scanf("%d %d %d", &begin, &n, &K);
    for (int i = 0; i < n; i++) {
        scanf("%d", &address);
        scanf("%d %d", &node[address].data, &node[address].next);
        node[address].address = address;
    }
    
    int p = begin, count = 0;//count计数有效结点的数目
    while (p != -1) {
        node[p].order = count++;
        p = node[p].next;
    }
    sort(node, node + maxn, cmp);
    n = count;
    for (int i = 0; i < n / K; i++) {
        for (int j = (i + 1) * K - 1; j > i * K; j--) {
            printf("%05d %d %05d", node[j].address, node[j].data, node[j - 1].address);
        }
        //每一步的最后一块都要单独处理
        printf("%05d %d ", node[i * K].address, node[i].data);
        if (i < n / K - 1) {
            printf("%05d\n", node[(i + 2) * K - 1].address);
        }
        else{
            if(n % K == 0) printf("-1\n");
            else{
                printf("%05d\n", node[(i + 1) * K].address);
                for (int i = n / K * K; i < n; i++) {
                    printf("%05d %d ", node[i].address, node[i].data);
                    if (i < n - 1) {
                        printf("%05d\n", node[i + 1].address);
                    }
                    else printf("-1\n");
                }
            }
        }
    }
    
    
    return 0;
};
```

```C++
//1032 Sharing (25 分)
//第一种方法，实在是高效
//从基地址甲开始遍历中间把遍历到的地址flag设为true（初始化全部为false）
//从基地址乙开始遍历当检查到遍历的地址下flag为true时，说明遇到了甲乙首个公共结尾字母，输出当前地址并跳出（地址记得使用%05d格式输出地址）
struct node{
    char letter;
    int next;
    bool flag;
}ls[maxn];



int main(){
    for (int i = 0; i < maxn; i++) {
        ls[i].flag = false;
    }
    
    int base1, base2, N, address;
    scanf("%d %d %d", &base1, &base2, &N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &address);
        scanf(" %c ", &ls[address].letter);
        scanf("%d", &ls[address].next);
    }
    while (base1 != -1) {
        ls[base1].flag = true;
        base1 = ls[base1].next;
    }
    
    bool print = true;
    while (base2 != -1) {
        if (ls[base2].flag == true) {
            print = false;
            printf("%05d\n", base2);
            break;
        }
        base2 = ls[base2].next;
    }
    if (print) {
        printf("-1\n");
    }
    
    return 0;
};
```


```C++
//1032 Sharing (25 分)
//第二种方法，分别从两个首地址遍历生成两个字符串，然后倒转，从第一位开始比较（期间记录比较的字符是哪个），不等则跳出。common=0则输出-1，
//不为0则拿着跳出前最后一次得到的字符到链表里找，找到即输出地址并跳出。
//方法比书上麻烦了，而且最后一个数据点报超时。还是用书上的
struct node{
    char letter;
    int next;
}ls[maxn];

void reverse(char str[], char str_new[]){
    int len = strlen(str), temp = 0;
    for (int i = len - 1; i >= 0; i--) {
        str_new[temp++] = str[i];
    }
}

int main(){
    int base1, base2, N, address;
    scanf("%d %d %d", &base1, &base2, &N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &address);
        scanf(" %c ", &ls[address].letter);
        scanf("%d", &ls[address].next);
    }
    
    char str1[maxn], str2[maxn];
    
    int ind = 0;
    int p = base1;
    while (p != -1) {
        str1[ind++] = ls[p].letter;
        p = ls[p].next;
    }
    ind = 0;
    while (base2 != -1) {
        str2[ind++] = ls[base2].letter;
        base2 = ls[base2].next;
    }
    
    
    char str1_re[maxn], str2_re[maxn];
    reverse(str1, str1_re);
    reverse(str2, str2_re);
//    printf("%s %s\n", str1_re, str2_re);
    int common = 0;
    char first;
    for (int i = 0; i < strlen(str1_re) && i < strlen(str2_re); i++) {
        if (str1_re[i] == str2_re[i]) {
            common++;
            first = str1_re[i];
        }
        else break;
    }
    if (common) {
        int p = base1;
        while (p != -1) {
            if (first == ls[p].letter) {
                printf("%05d\n", p);
                break;
            }
            p = ls[p].next;
        }
    }
    else printf("-1\n");
    
    return 0;
};

```
