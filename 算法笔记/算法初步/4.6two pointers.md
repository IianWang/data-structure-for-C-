# 第四章 入门篇（2）---- 算法初步
## 4.6 two pointers
### 4.6.1 什么是 two pointers
two pointers 实质上是利用数列的递增特性，以浅显的思想降低复杂度
eg.在一个有序的递增（递减）数列中找到两个元素，使其相加等于M，问有多少组？

常规思路：嵌套for循环，复杂度O(n)

two pointers: 从数列的两头分别向中间遍历，面对可能出现的三种情况做出相应的操作
```C++
int i = 0;
int j = N - 1;
while(i < n && j >= 0){
  if(ls[i] + ls[j] == M){
      print("%d %d", i, j);
      i++;
      j--;
  }
  else if(ls[i] + ls[j] > M){
      //此时都已经大于M了，i再往右移动肯定更大了，i，j同时往中间移动那么结果是大是小也说不好，故只移动j
      j--;
  }
  else{
      //反之
      i++;
  }

}
```

### 4.6.2 归并排序
如果将一个n项数列排序的话，目前学了三种
- 冒泡O(n^2)
- 插入O(n^2)
- 选择O(n^2)
上述最基础的三种排序复杂度都是O(n^2)

不过归并排序可以把复杂度降至为O(nlogn)
算法思想：
1. 将原始数组先两个一组，进行"分割"，eg.{9, 66, 11, 55, 3} -> {{9, 66}, {11, 55}, {3}}（并不需要真的在程序中搞这种高维数组，一维就够了）
2.将每个小数组排序，然后合并到上一级
```C++
//代码：递归实现
void merge(int A[], int L1, int L2, int R1, int R2){
    int temp[maxn], index = 0;
    int j = L1, k = L2;
    while(j <= R1 && k <= R2){//这里小于等于，等于别落下了
        if(A[j] < A[k]){
            temp[index++] = A[j++];
        }
        else{
            temp[index++] = A[k++];
        }
    }
    while(j <= R1) temp[index++] = A[j++];//这里也是
    while(k <= R2) temp[index++] = A[k++];
    for(int i = 0; i < index; i++){
        A[L1 + i] = temp[i];//这里是L1 + i不是i，因为每次传入的左端点L1都是分割后的，在原数组中位置不为0
    }
}

void mergeSort(int A[], int left, int right){
    if(left < right){
        int mid = (right + left) / 2;
        mergeSort(A, left, mid);
        mergeSort(A, mid + 1, right);
        merge(A, left, mid, mid + 1, right);
    }
}
```

```C++
//非递归实现
//尚未理解清楚
void mergeSort(int A[]){
    for(int step = 2, step / 2 <= n; step *= 2){
        for(int i = 1; i <= n; i += step){
            int mid = i + step / 2 - 1;
            if(mid + 1 <= n){
                merge(A, i, mid, mid + 1, min(i + step - 1, n));
            }
        }
    }
}
```

### 4.6.3 快速排序排序

快排一般情况下时间复杂度都是O(nlogn)，
不过在某个特殊的情况下是O(n^2)，当数列是单调递增/递减的时候
看下quickSort函数内的两个自我调用，当出现上面的特例时，有一个自我调用是不运作的，也就是一开始left = pos - 1或者 pos + 1 = right，
解决办法就像书上所说的，每次用一个随机位置的数充当temp(主元)

```C++
//递归实现快速排序
int partition(int A[], int left, int right){
    int temp = A[left];
    while(left < right){
        while(A[right] > temp && left < right) right--;
        A[left] = A[right];
        while(A[left] <= temp && left < right) left++;
        A[right] = A[left];
    }
    A[left] = temp;
    return left;
}

void quickSort(int A[], int left, int right){
    if(left < right){
        int pos = partition(A, left, right);
        quickSort(A, left, pos - 1);
        quickSort(A, pos + 1, right);
    }
}
```



