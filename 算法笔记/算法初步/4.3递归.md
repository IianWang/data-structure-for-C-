# 第四章 入门篇（2）---- 算法初步
## 4.3 递归
### 4.3.1 分治
### 4.3.2 递归

codeup
```C++
//递归目前理解起来还是比较吃力的
//虽然知道递归边界和递归通项两个重点，不过还是抓不准题干的递归边界和通项，在脑海构思两者过程中造成逻辑混乱
//多想想多练练看看
//问题 A: 吃糖果
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>

using namespace std;
const int maxn = 11;
int n = 0, hashTable[maxn] = {false}, ls[maxn] = {0};

int generateP(int N){
    if (N == 2) {
        return 2;
    }
    else if (N == 1) return 1;
    else return generateP(N - 1) + generateP(N - 2);
}

int main(){

    
    int K;
    while (scanf("%d", &K) != EOF) {
        printf("%d\n", generateP(K));
    }

    return 0;
};

```

```C++
//问题 B: 数列
//输出fibonacci三角形
//题目要求递归，一种比较简便的方法是关于fib计算可以写成递归函数，格式输出可以用循环写在主程序中
//该题最开始想的是格式输出与fib计算一并写在递归函数中，结果写不出来。。
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>

using namespace std;
const int maxn = 11;
int n = 0, hashTable[maxn] = {false}, ls[maxn] = {0}, total;

int fib(int n){
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}

int main(){

    int N, M;
    
    scanf("%d", &N);
    while (N--) {
        scanf("%d", &M);
        for (int i = 1; i <= M; i++) {
            for (int k = 1; k <= (M - i) * 2; k++) printf(" ");
            for (int j = 1; j <= 1 + 2 * (i - 1); j++) {
                printf("%d ", fib(j));
            }
            printf("\n");
        }
    }

    return 0;
};

```

```C++
//复习！
//问题 C: 神奇的口袋
//问题：从M个数中选出N个满足条件的数
//思路：运用递归思想，需要先明确两个核心；1、递归边界怎么设置什么？2、递归通项是什么？
//确定两个核心前先要确定核心算法思想，该题的问题是“从M个数中选出N个相加等于40的数，问一个能选出多少种不同的方案”
//直观的是遍历，固定第一个数，对剩下的M - 1个数中进行挑N - 1个数，这期间对满足条件的count+1，都挑过了之后固定第
//二个数对剩下的M - 2个数中挑N - 1个数(排除了第一轮中的第一个数，避免统计到重复的组合)，以此类推直到M - K < N - 1(因为剩余的个数不够挑出N - 1个数了)，
//如何判断满足count+1的条件？
//令total = total - ls[i] // total的初始值为40，ls[i]为数组中第i项的数，当total = 0时满足count+1的条件
//另外还有一个重点，比如说5选2，固定数组中第一个数判断数组第二个数，结果total != 0，此时判断组合不满足后应当再把第二个数加回来减数组第三个数（
//还原，不加回来就开始减下一个数就不是5选2了，仔细体会）
//递归边界(2个)：1、当 total < 0时候返回0（此时无论减没减足N个数再往下都没有意义了，果断返回0中断掉）
//2、total = 0，（此处有个疑问，如果是5选3，那在第二次减完total = 0了怎么办？total = 0 -> count + 1 有没有执行？，原则上不应该让它执行）
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>

using namespace std;
const int maxn = 30;
int N, ls[maxn] = {0}, total, counts;

int generateP(int index){
    if (total < 0) return 0;
    else if (total == 0) {
        counts++;
        return 0;
    }
    if (index == N) return 0;
    for (int i = index; i < N; i++) {
        total = total - ls[i];
        generateP(i + 1);
        total = total + ls[i];
    }
    return 0;
}
int main(){
    while (scanf("%d", &N) != EOF) {
        total = 40;
        counts = 0;
        for (int i = 0; i < N; i++) {
            scanf("%d", &ls[i]);
        }
        generateP(0);
        printf("%d\n", counts);
    }


    return 0;
};

```
