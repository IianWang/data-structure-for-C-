# 第四章 入门篇（2）---- 算法初步
## 4.4 贪心
### 4.4.1 简单贪心
### 4.4.2 区间贪心

教材上给的两道简单贪心的题目，并没有感觉出和正常思路有何不同。

1020 月饼 (25 分)
1023 组个最小数 (20 分)

codeup
```C++
//问题 A: 看电视
//与数最大的相互独立的区间的问题是一致的
//重点在于排序函数还有counts++后并更新新的左端点base
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>

using namespace std;

struct tv{
    int x, y;
}ls_tv[110];

bool cmp(tv a, tv b){
    if (a.x != b.x) {
        return a.x > b.x;
    }
    else return a.y < b.y;
}

int main(){
    int n;
    while (scanf("%d", &n) != EOF) {
        if (n == 0) break;
        for (int i = 0; i < n; i++) {
            scanf("%d %d", &ls_tv[i].x, &ls_tv[i].y);
        }
        sort(ls_tv, ls_tv + n, cmp);
        int base = ls_tv[0].x, counts = 1;
        for (int i = 1; i < n; i++) {
            if (ls_tv[i].y <= base) {
                //            printf("i = %d, base = %d\n", i, base);
                counts++;
                base = ls_tv[i].x;
            }
        }
        printf("%d\n", counts);
    }  
    
    return 0;
};
```

```C++
//该题重新看，codeup没过
//问题 B: 出租车费
//复习
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;


int main(){
    double route;
    while (scanf("%lf", &route) != EOF) {
        if (route == 0) {
            break;
        }
        int cars;
        double total = 0;
        
        for (int i = 1; i < route; i++) {
            double times = route / 4.0;
            if (times > 2 * i - 1 && times < 2 * i + 1) {
                cars = i;
//                printf("i = %d \n", i);
                break;
            }
        }
        if (cars > 1) {
            route = route - (cars - 1) * 8;
            total += (cars - 1) * 18;
        }
        
        if (route >= 4){
            if (route >= 8) total = total + 10 + 8 + ceil(route - 8) * 2.4;
            else total = total + 10 + ceil(route - 4) * 2;
        }
        else total += 10;
        if (total == ceil(total)) {
            printf("%.0lf\n", total);
        }
        else printf("%.1lf\n", total);
    }
    
    return 0;
};

```

```C++
//1033 To Fill or Not to Fill (25 分)
//加油站，照着答案抄的，被搞得有点迷
//复习！+ 重做
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 520;
const int INF = 1000000000;

struct station{
    double price, dis;
}st[maxn];

bool cmp(station a, station b){
    return a.dis < b.dis;
}

int main(){
    int n;
    double Cmax, D, Davg;
    scanf("%lf %lf %lf %d", &Cmax, &D, &Davg, &n);
    for (int i = 0; i <n; i++) {
        scanf("%lf %lf", &st[i].price, &st[i].dis);
    }
    st[n].price = 0;
    st[n].dis = D;
    sort(st, st + n, cmp);
    if (st[0].dis != 0) {
        printf("The maximum travel distance = 0.00");
    }
    else{
        int now = 0;
        double ans = 0, nowTank = 0, MAX = Cmax * Davg;
        while (now < n) {
            int k = -1;
            double priceMin = INF;
            for (int i = now + 1; i <= n && st[i].dis - st[now].dis <= MAX; i++) {
                if (st[i].price < priceMin) {
                    priceMin = st[i].price;
                    k = i;
                    if(priceMin < st[now].price) break;
                }
            }
            if (k == -1) break;
            double need = (st[k].dis - st[now].dis) / Davg;
            if (priceMin < st[now].price){
                if (nowTank < need) {
                    ans += (need - nowTank) * st[now].price;
                    nowTank = 0;
                }
                else nowTank -= need;
            }
            else {
                ans += (Cmax - nowTank) * st[now].price;
                nowTank = Cmax - need;
            }
            now = k;
        }
        if (now == n){
            printf("%.2f\n", ans);
        }
        else{
            printf("The maximum travel distance = %.2f\n", st[now].dis + MAX);
        }
    }

    
    return 0;
};

```

```C++
//1037 Magic Coupon (25 分)
//代表性的题干不好读，代码却异常的好编写
//后续像这种计算最优解的题，一定要先在草稿纸上模拟一遍自己的想法，和样例答案做个对比，正确再开始写程序
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 100010;
const int INF = 1000000000;

bool cmp1(long long a, long long b){
    return a < b;
}
bool cmp2(long long a, long long b){
    return a > b;
}

int main(){
    long long token[maxn], bonus[maxn], total = 0;
    int N, K, base;
    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        scanf("%lld", &token[i]);
    }
    scanf("%d", &K);
    for (int i = 0; i < K; i++) {
        scanf("%lld", &bonus[i]);
    }
    sort(token, token + N, cmp1);
    sort(bonus, bonus + K, cmp1);
    if (N > K) base = K;
    else base = N;
    for (int i = 0; i < base; i++) {
        if (token[i] < 0 && bonus[i] < 0) {
            total += token[i] * bonus[i];
        }
        else break;
    }
    sort(token, token + N, cmp2);
    sort(bonus, bonus + K, cmp2);
    for (int i = 0; i < base; i++) {
        if (token[i] > 0 && bonus[i] > 0) {
            total += token[i] * bonus[i];
        }
        else break;
    }
    printf("%lld\n", total);
    return 0;
};

```

```C++
//1067 Sort with Swap(0, i) (25 分)
//19分代码，有两个数据点报超时，应该是自定义swap函数调用太多了
//不过我这个逻辑依赖的是swap里的自动找寻下一个被交换的目标（这个过程是遍历）
//要改的话需要重构逻辑
//重做+复习
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 100010;
const int INF = 1000000000;
int ls[maxn], aux[maxn], total = 0;
int N;

    int swap(int a, int b){
        int MIN, loc;
        MIN = ls[b];//b : index zero , MIN : zero
        for (int i = 0; i < N; i++) {
            if(i == 0 && b == 0 && ls[i] == aux[b]) {
                total--;
                break;
            }
            else if (ls[i] == aux[b]){//寻找另一项被交换数的位置
                ls[b] = ls[i];
                ls[i] = MIN;
                loc = i;
                break;
            }
        }
        total++;
        return loc;
    };


int main(){


    bool flag = true;
    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &ls[i]);
        aux[i] = ls[i];
    }
    sort(aux, aux + N);//默认是升序
    int index = 0, zero;
    for (int i = 0; i < N; i++) {//找最小值的位置
        if (ls[i] == aux[0]){
            index = i;
            break;
        }
    }
    zero = index;
    while (flag) {
        if (N == 0 || N == 1) {
            break;
        }

        zero = swap(aux[0], zero);
//        for (int i = 0; i < N; i++) {
//            printf("%d ", ls[i]);
//        }
//        printf("\n");
        if (ls[0] == aux[0]){//判断特殊情况
            for (int i = 0; i < N - 1; i++) {
                if (ls[i] < ls[i + 1]) {
                    flag = false;
                    continue;
                }
                else{//处理特殊情况
                    int temp = ls[i];
                    ls[i] = aux[0];
                    ls[zero] = temp;
                    zero = i;//更新最小值位置
                    flag = true;
                    total ++;//处理特殊情况也算做一次交换这里别忘了加
                    break;
                }
            }
        }
    }
    if (flag) {
        printf("%d\n", total);
    }
    else printf("%d\n", total);
    
    
    return 0;
};

```

```C++
//1038 Recover the Smallest Number (30 分)
//看了书上的思路和参考代码后才发觉这是一道无论是算法及代码都很简单的一道30分题，估计不太可能作为30分题出现在考试中（依然有可能在20、25分题中）
//给出一堆字符串，问你如何拼接，使得拼接后的结果字符串值最小（如果开头有0则去掉0）
//思路：eg.321 + 32 < 32 + 321。
//故可以利用这一算法思想运用sort+cmp排序，就是最终我们要的排列顺序（只是最终算法思想简单但精巧，初次遇到不太想的到，需要第二遍复习过一下）
//此外，本次还用到了string（处理字符串数组有很多现成的函数，比较方便，本次用的 .size()、.erase()、.begin()）
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 10010;
const int INF = 1000000000;
string str[maxn];

bool cmp(string a, string b){
    return a + b < b + a;
}


int main(){
    int N;
    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        cin >> str[i];
    }
    sort(str, str + N, cmp);
    string ans;
    for (int i = 0; i < N; i++) {
        ans += str[i];
    }
    while (ans.size() != 0 && ans[0] == '0') {
        ans.erase(ans.begin());
    }
    if (ans.size() == 0) {//别忘了结果字符串为零的情况
        printf("0");
    }
    else printf("%s\n", ans.c_str());
    
    
    return 0;
};

```

```C++
//Repair the Wall
//codeup
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 10010;
const int INF = 1000000000;
long long L, N;
long long ls[610] = {0};

bool cmp(long long a, long long b){
    return a > b;
}

int main(){
    while (scanf("%lld %lld", &L, &N) != EOF) {
        for (int i = 0; i < N; i++) {
            scanf("%lld", &ls[i]);
        }
        sort(ls, ls + N, cmp);
        int total = 0;
        
        for (int i = 0; i < N; i++) {
            L = L - ls[i];
            total++;
            if(L < 0) break;
        }
        if (L > 0) {
            printf("impossible\n");
        }
        else printf("%d\n", total);
    }
    

    return 0;
};
```

```C++
//FatMouse's Trade
//codeup
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 1010;
const int INF = 1000000000;
double M;
int N;

struct conbin{
    double JB;
    double FD;
    double AVG;
}ls[maxn];

bool cmp(conbin a, conbin b){
    if (a.AVG != b.AVG) return a.AVG > b.AVG;
    return a.JB > b.JB;
}

int main(){
    
    while (scanf("%lf %d", &M, &N) != EOF) {
        double total = 0;
        if (M == -1.0 && N == -1) break;
        for (int i = 0; i < N; i++) {
            scanf("%lf %lf", &ls[i].JB, &ls[i].FD);
            if (ls[i].FD == 0) ls[i].AVG = 0;
            else ls[i].AVG = ls[i].JB / ls[i].FD;
        }
        sort(ls, ls + N, cmp);
        
        for (int i = 0; i < N; i++) {
            if (M * ls[i].AVG > ls[i].JB){
                M = M - ls[i].FD;
                total += ls[i].JB;
            }
            else{
                total += ls[i].AVG * M;
                break;
            }
                    }
        printf("%.3lf\n", total);

    }

    return 0;
};

```
