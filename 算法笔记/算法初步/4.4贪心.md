# 第四章 入门篇（2）---- 算法初步
## 4.4 贪心
### 4.4.1 简单贪心
### 4.4.2 区间贪心

教材上给的两道简单贪心的题目，并没有感觉出和正常思路有何不同。

1020 月饼 (25 分)
1023 组个最小数 (20 分)

codeup
```C++
//问题 A: 看电视
//与数最大的相互独立的区间的问题是一致的
//重点在于排序函数还有counts++后并更新新的左端点base
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>

using namespace std;

struct tv{
    int x, y;
}ls_tv[110];

bool cmp(tv a, tv b){
    if (a.x != b.x) {
        return a.x > b.x;
    }
    else return a.y < b.y;
}

int main(){
    int n;
    while (scanf("%d", &n) != EOF) {
        if (n == 0) break;
        for (int i = 0; i < n; i++) {
            scanf("%d %d", &ls_tv[i].x, &ls_tv[i].y);
        }
        sort(ls_tv, ls_tv + n, cmp);
        int base = ls_tv[0].x, counts = 1;
        for (int i = 1; i < n; i++) {
            if (ls_tv[i].y <= base) {
                //            printf("i = %d, base = %d\n", i, base);
                counts++;
                base = ls_tv[i].x;
            }
        }
        printf("%d\n", counts);
    }  
    
    return 0;
};
```

```C++
//该题重新看，codeup没过
//问题 B: 出租车费
//复习
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;


int main(){
    double route;
    while (scanf("%lf", &route) != EOF) {
        if (route == 0) {
            break;
        }
        int cars;
        double total = 0;
        
        for (int i = 1; i < route; i++) {
            double times = route / 4.0;
            if (times > 2 * i - 1 && times < 2 * i + 1) {
                cars = i;
//                printf("i = %d \n", i);
                break;
            }
        }
        if (cars > 1) {
            route = route - (cars - 1) * 8;
            total += (cars - 1) * 18;
        }
        
        if (route >= 4){
            if (route >= 8) total = total + 10 + 8 + ceil(route - 8) * 2.4;
            else total = total + 10 + ceil(route - 4) * 2;
        }
        else total += 10;
        if (total == ceil(total)) {
            printf("%.0lf\n", total);
        }
        else printf("%.1lf\n", total);
    }
    
    return 0;
};

```

```C++
//1033 To Fill or Not to Fill (25 分)
//加油站，照着答案抄的，被搞得有点迷
//复习！+ 重做
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 520;
const int INF = 1000000000;

struct station{
    double price, dis;
}st[maxn];

bool cmp(station a, station b){
    return a.dis < b.dis;
}

int main(){
    int n;
    double Cmax, D, Davg;
    scanf("%lf %lf %lf %d", &Cmax, &D, &Davg, &n);
    for (int i = 0; i <n; i++) {
        scanf("%lf %lf", &st[i].price, &st[i].dis);
    }
    st[n].price = 0;
    st[n].dis = D;
    sort(st, st + n, cmp);
    if (st[0].dis != 0) {
        printf("The maximum travel distance = 0.00");
    }
    else{
        int now = 0;
        double ans = 0, nowTank = 0, MAX = Cmax * Davg;
        while (now < n) {
            int k = -1;
            double priceMin = INF;
            for (int i = now + 1; i <= n && st[i].dis - st[now].dis <= MAX; i++) {
                if (st[i].price < priceMin) {
                    priceMin = st[i].price;
                    k = i;
                    if(priceMin < st[now].price) break;
                }
            }
            if (k == -1) break;
            double need = (st[k].dis - st[now].dis) / Davg;
            if (priceMin < st[now].price){
                if (nowTank < need) {
                    ans += (need - nowTank) * st[now].price;
                    nowTank = 0;
                }
                else nowTank -= need;
            }
            else {
                ans += (Cmax - nowTank) * st[now].price;
                nowTank = Cmax - need;
            }
            now = k;
        }
        if (now == n){
            printf("%.2f\n", ans);
        }
        else{
            printf("The maximum travel distance = %.2f\n", st[now].dis + MAX);
        }
    }

    
    return 0;
};

```

```C++
//1037 Magic Coupon (25 分)
//代表性的题干不好读，代码却异常的好编写
//后续像这种计算最优解的题，一定要先在草稿纸上模拟一遍自己的想法，和样例答案做个对比，正确再开始写程序
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 100010;
const int INF = 1000000000;

bool cmp1(long long a, long long b){
    return a < b;
}
bool cmp2(long long a, long long b){
    return a > b;
}

int main(){
    long long token[maxn], bonus[maxn], total = 0;
    int N, K, base;
    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        scanf("%lld", &token[i]);
    }
    scanf("%d", &K);
    for (int i = 0; i < K; i++) {
        scanf("%lld", &bonus[i]);
    }
    sort(token, token + N, cmp1);
    sort(bonus, bonus + K, cmp1);
    if (N > K) base = K;
    else base = N;
    for (int i = 0; i < base; i++) {
        if (token[i] < 0 && bonus[i] < 0) {
            total += token[i] * bonus[i];
        }
        else break;
    }
    sort(token, token + N, cmp2);
    sort(bonus, bonus + K, cmp2);
    for (int i = 0; i < base; i++) {
        if (token[i] > 0 && bonus[i] > 0) {
            total += token[i] * bonus[i];
        }
        else break;
    }
    printf("%lld\n", total);
    return 0;
};

```

```C++
//1067 Sort with Swap(0, i) (25 分)
//19分代码，有两个数据点报超时，应该是自定义swap函数调用太多了
//不过我这个逻辑依赖的是swap里的自动找寻下一个被交换的目标（这个过程是遍历）
//要改的话需要重构逻辑
//重做+复习
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
const int maxn = 100010;
const int INF = 1000000000;
int ls[maxn], aux[maxn], total = 0;
int N;

    int swap(int a, int b){
        int MIN, loc;
        MIN = ls[b];//b : index zero , MIN : zero
        for (int i = 0; i < N; i++) {
            if(i == 0 && b == 0 && ls[i] == aux[b]) {
                total--;
                break;
            }
            else if (ls[i] == aux[b]){//寻找另一项被交换数的位置
                ls[b] = ls[i];
                ls[i] = MIN;
                loc = i;
                break;
            }
        }
        total++;
        return loc;
    };


int main(){


    bool flag = true;
    scanf("%d", &N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &ls[i]);
        aux[i] = ls[i];
    }
    sort(aux, aux + N);//默认是升序
    int index = 0, zero;
    for (int i = 0; i < N; i++) {//找最小值的位置
        if (ls[i] == aux[0]){
            index = i;
            break;
        }
    }
    zero = index;
    while (flag) {
        if (N == 0 || N == 1) {
            break;
        }

        zero = swap(aux[0], zero);
//        for (int i = 0; i < N; i++) {
//            printf("%d ", ls[i]);
//        }
//        printf("\n");
        if (ls[0] == aux[0]){//判断特殊情况
            for (int i = 0; i < N - 1; i++) {
                if (ls[i] < ls[i + 1]) {
                    flag = false;
                    continue;
                }
                else{//处理特殊情况
                    int temp = ls[i];
                    ls[i] = aux[0];
                    ls[zero] = temp;
                    zero = i;//更新最小值位置
                    flag = true;
                    total ++;//处理特殊情况也算做一次交换这里别忘了加
                    break;
                }
            }
        }
    }
    if (flag) {
        printf("%d\n", total);
    }
    else printf("%d\n", total);
    
    
    return 0;
};

```
