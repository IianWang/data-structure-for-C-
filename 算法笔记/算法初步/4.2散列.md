# 第四章 入门篇（2）---- 算法初步
## 4.2 散列
### 4.2.1 散列的定义与整数散列
### 4.2.2 字符串hash初步

```C++
//问题 B: 分组统计
//代码来源于网络，设计的很巧妙，"组名"与"值"分别想象成x和y，存在矩阵的第一行与第一列，其余的部分存放"组名"下的某"值"的个数（一共需要一个二维数组和一个矩阵）
//复习
//该题我最初想的就麻烦死了，又要好几个数组存放组名、去重后的组名、值、去重后的值，外加一矩阵存放组名-值的个数

#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <algorithm>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111
#include <map>

int hashTable[2000][2000];
int a[110] = {0};

using namespace std;
int main()
{
    int m;
    scanf("%d", &m);
    while(m--){
        memset(hashTable, 0, sizeof(hashTable));
        memset(a, 0, sizeof(a));
        int n;
        scanf("%d", &n);
        int max_ = 0;
        for(int i = 1; i <=n; i++){
            scanf("%d", &a[i]);
            if(a[i] > max_) max_ = a[i];
            hashTable[0][a[i]] = 1;
        }
        int max_group = 0;
        for(int i = 1; i <=n; i++){
            int x;
            scanf("%d", &x);
            hashTable[x][a[i]]++;
            if(x > max_group) max_group = x;
            hashTable[x][0] = 1;
        }
        for(int i = 1; i <=max_group; i++){
            if(hashTable[i][0] == 0) continue;
            printf("%d={", i);
            for(int j = 1; j <=max_; j++){
                if(hashTable[0][j] == 0) continue;
                printf("%d=%d", j, hashTable[i][j]);
                if(j != max_) printf(",");
            }
            printf("}", i);
            printf("\n");
        }

    }




    return 0;
}

```

```C++
//Be Unique (20)
//基础的散列问题，读懂题就可以做出来了
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <algorithm>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111
#include <map>

int hashTable[100100] = {0};
int ls[100100] = {0};

using namespace std;
int main()
{
    int m;
    while(scanf("%d", &m) != EOF){
        memset(hashTable, 0, sizeof(hashTable));
        memset(ls, 0, sizeof(ls));
        int max_ = 0;
        for(int i = 0; i <m; i++){
            int n;
            scanf("%d", &ls[i]);
            hashTable[ls[i]]++;
            if(ls[i] > max_) max_ = ls[i];
        }
        int k = 1;
        for(int j = 0; j <m; j++){
            if(hashTable[ls[j]] == 1){
                printf("%d\n", ls[j]);
                k = 0;
                break;
            }
        }
        if(k) printf("None\n");
    }

    return 0;
}

```

```C++
//String Subtraction (20)
//字符可以在不强制转换int的情况下直接进行索引
//该题运行时间给的有限，如果赋值、索引两者都先进行强制转换，则超时

#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <algorithm>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111
#include <map>

int hashTable[100100] = {0};
int ls[100100] = {0};

using namespace std;
int main()
{
    char str1[10010], str2[10010];
    cin.getline(str1, 10010);
    cin.getline(str2, 10010);
    for(int i = 0; i <strlen(str1); i++){
        hashTable[str1[i]] = 1;
    }
    for(int i = 0; i <strlen(str2); i++){
        hashTable[str2[i]] = 0;
    }
    for(int i = 0; i <strlen(str1); i++){
        if(hashTable[str1[i]] == 1){
            printf("%c", str1[i]);
        }

    }
    printf("\n");




    return 0;
}

```


