# 第五章 入门篇（3）---- 数学问题
## 5.5 质因子的分解

质因子：顾名思义，为质数的因子称之为质因子，eg.2、3、7、11等，8、9、12、14、15等则不是

质因子有一个定理：
- 要么一个大于√n，剩下的质因子都小于√n。
- 要么全部都比√n小。
以上是针对"质因子"的定理。



```C++
//问题 A: 完数
//枚举出n所有的因子，若他们的和等于n则输出n
//浪费时间严重的一道题，在理解错误基础上搞个没完，后来才发现是所有因子，不是所有质因子。
//实际代码很简单，复习！
int isperfect(int x){
    int sum = 0;
    for(int i = 1; i <= x / 2; i++){
        if(x%i == 0) {
            if(x == 28) printf("sum = %d\n", sum);
            sum +=i;
        }
    }
    if(sum == x) return 1;
    else return 0;
}
int main(int argc, char** argv) {
    int n;
    while(cin >> n) {
        int flag = 1;
        for(int i = 6; i <= n; i++){
            if(isperfect(i)){
                if(flag){
                    cout << i;
                    flag = 0;
                }else{
                    cout << " " << i;
                }
            }
        }
        cout << endl;
    }
    return 0;
}

```

```C++
//问题 C: 质因数的个数
//题目给的n阈值是10^9，不可能搞那么大的数组
//两个重要函数
//1. find_num，枚举质数获取质数表（埃氏、常规√n，任用其一）
//2. divisor，质因子分解函数
//复习，主要复习上面两个函数
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#define maxn 100100

using namespace std;
int ls[maxn] = {0}, ls_remain[maxn] = {0}, temp = 0;

void find_num(int n){
    for (int i = 2; i < n; i++) {
        if (ls[i] == false) {
            ls_remain[temp++] = i;
            for (int j = i + i; j < n; j += i) {
                ls[j] = true;
            }
        }
    }
}

struct node{
    int num, counts;
}nodeList[10];

int category = 0;
void divisor(int n){
    for (int i = 0; i < temp; i++) {
        if(n % ls_remain[i] == 0){
            nodeList[category].num = ls_remain[i];
            nodeList[category].counts = 0;
            while (n % ls_remain[i] == 0) {
                nodeList[category].counts++;
                n /= ls_remain[i];
            }
            category++;
        }
    }
    if (n != 1) {//如果n没被sqrt(n)之前的的质数除尽，说明还剩下最后一个比sqrt(n)大的因子，就是n(除过sqrt(n)之前质数的n)
        //这里后续要留意，要判断n != 1。category==0会漏判
        nodeList[category].num = n;
        nodeList[category++].counts = 1;
    }
}

int main(){
    int n;
    
    while (scanf("%d", &n) != EOF) {
        temp = 0;
        category = 0;
        find_num(maxn);
        divisor(n);
        int sum = 0;
        for (int i = 0; i < category; i++) {
            sum += nodeList[i].counts;
        }
        printf("%d\n", sum);
    }
    return 0;
};

```

```C++
//1059 Prime Factors (25 分)
//关于给定任意数与因子有关的题，需要考虑程序的盲区，比如这道题当输入数据为1时，1其实不是质数也没有质因子，程序内没有写，不过却需要考虑到数据点为，该题目有两分数据点
//特别是题干中没说输入的n的范围时候
//复习的时候记下这个点
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#define maxn 100100

using namespace std;
typedef long long ll;

ll ls[maxn] = {0}, ls_remain[maxn] = {0}, temp = 0;

void find_num(ll n){
    for (ll i = 2; i < n; i++) {
        if (ls[i] == false) {
            ls_remain[temp++] = i;
            for (int j = i + i; j < n; j += i) {
                ls[j] = true;
            }
        }
    }
}

struct node{
    ll num, counts;
}nodeList[10];

ll category = 0;
void divisor(ll n){
    for (ll i = 0; i < temp; i++) {
        if(n % ls_remain[i] == 0){
            nodeList[category].num = ls_remain[i];
            nodeList[category].counts = 0;
            while (n % ls_remain[i] == 0) {
                nodeList[category].counts++;
                n /= ls_remain[i];
            }
            category++;
        }
    }
    if (n != 1) {//如果n没被sqrt(n)之前的的质数除尽，说明还剩下最后一个比sqrt(n)大的因子，就是n(除过sqrt(n)之前质数的n)
        //这里后续要留意，要判断n != 1。category==0会漏判
        nodeList[category].num = n;
        nodeList[category++].counts = 1;
    }
}

int main(){
    ll n;
    scanf("%lld", &n);
    temp = 0;
    category = 0;
    find_num(maxn);
    divisor(n);
    
    if (n == 1) {
        printf("1=1");
    }
    
    for (int i = 0; i < category; i++) {
        if (i == 0) {
            printf("%lld=", n);
        }
        printf("%lld", nodeList[i].num);
        if (nodeList[i].counts > 1) {
            printf("^");
            printf("%lld", nodeList[i].counts);
        }
        if(category - i != 1) printf("*");
    }

    
    return 0;
};

```
