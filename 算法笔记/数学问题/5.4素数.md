# 第五章 入门篇（3）---- 数学问题
## 5.4 素数
### 5.4.1 素数的判断

素数（质数）除了1和它本身不能被任何数整除，0 和 1 既不是素数也不是合数

### 5.4.2 素数表的获取

关于素数表的获取共有两个
1. 对n个数，每个数开根号后都进行一次 i++ < √n的 n % i == 0的判断，复杂度O(n*√n)，一般n < 10^5都可以
2. 埃氏筛法，遍历列表，删除i的倍数i ∈ [2, n)，复杂度O(nloglogn)

显然，第二种更佳

```C++
//问题 B: Prime Number
//采用第二种方法
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#define maxn 1001000

using namespace std;

int ls[maxn] = {0}, temp = 0, ls_new[maxn] = {0};

void Find_Prime(int n){
    for (int i = 2; i < n; i++) {//这里必须从而开始i = 1的话，任何数都被设置为true了
        if(ls[i] == false) {
            ls_new[temp++] = i;
            for (int j = i + i; j < n; j += i) {
                ls[j] = true;
            }
        }
    }
}

int main(){
    int N = 1000000, K;
    Find_Prime(N);
    while (scanf("%d", &K) != EOF) {
        printf("%d\n", ls_new[K - 1]);
    }
    return 0;
};

```

```C++
//问题 C: Goldbach's Conjecture
//给定一个数，要求输出两个不同的质数组成该数的组合的个数，不能是p1,p2; p2,p1
//用了一个埃氏筛法和两个散列列表
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#define maxn 100100

using namespace std;

int ls[maxn] = {0}, temp = 0, ls_new[maxn] = {0}, ls_index[maxn] = {0};

void Find_Prime(int n){
    for (int i = 2; i < n; i++) {//这里必须从而开始i = 1的话，任何数都被设置为true了
        if(ls[i] == false) {
            ls_new[temp++] = i;
            ls_index[i] = 1;;
            for (int j = i + i; j < n; j += i) {
                ls[j] = true;
            }
        }
    }
}

int main(){
    int N, K;
    
    while (scanf("%d", &N) != EOF) {
        int counts = 0;
        if(N == 0) break;
        ls_new[maxn] = {0};
        int ls_final[maxn] = {0};
        temp = 0;
        Find_Prime(N);
        for (int i = 0; i < temp; i++) {
            if (ls_index[N - ls_new[i]] == 1) {
                if (ls_final[ls_new[i]] == 0 && ls_final[N - ls_new[i]] == 0) {
                    ls_final[ls_new[i]] = 1;
                    ls_final[N - ls_new[i]] = 1;
                    counts++;
//                    printf("%d %d\n", ls_new[i], N - ls_new[i]);
                }
            }
        }
        printf("%d\n", counts);
    }
    
    return 0;
};


```
