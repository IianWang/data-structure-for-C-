# 第三章 入门篇（1）---- 入门模拟
## 3.6 字符串处理
省略了一些过于基础的题
codeup
```C++
//【字符串】回文串
//可以用能用strcmp，但需要在末尾加上'\0'
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111


using namespace std;
int main()
{

    char str[256];

    while(scanf("%s", str) != EOF){
        int n = 0;
        for(int i = 0; i <strlen(str) / 2; i++){
            if(str[i] != str[strlen(str) - i - 1]){
                n = 1;
                break;
            }

        }
        if(n == 1) printf("NO\n");
        else printf("YES\n");
    }

    return 0;
}



```

```C++
//第二钟方法判断回文，末尾加'\0'
//题外话'\0'也可以用来判断字符串的长度eg:if str[i] != '\0' i++
using namespace std;
int main()
{
    char str[100], str_n[100];

    int n = 0;
    while(scanf("%s", str) != EOF){
        char str_n[256];
        for(int i = 0; i <strlen(str); i++){
            str_n[i] = str[strlen(str) - i - 1];
            n++;
            if(strlen(str) - i == 1) str_n[i + 1] = '\0';
        }

        printf("str = %s, len = %d\n", str, strlen(str));
        printf("str_n = %s, len = %d\n", str_n, strlen(str));
        printf("%s\n", strcmp(str, str_n) == 0?"YES":"NO");
    }

    return 0;
}
```

```C++
// 1009 说反话 (20分)
// gets函数在PAT中有时候会提示格式错误，可以换成cin.getlines()，不过这道题用的另一种更简单的方法
// 针对PAT这种单点测试
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111


using namespace std;
int main()
{

    char str[256][256];
    int n = 0;
    while(scanf("%s", str[n]) != EOF){
        n++;
    }
    for(int i = 0; i <n; i++){
        printf("%s", str[n - i - 1]);
        if(i != n - 1) printf(" ");
    }


    return 0;
}
```

```C++
//复习！！
//问题 C: 字符串的查找删除
//有个重要的提示，给定字符串中包含空格，则慎用scanf(scanf把空格当做读取结束，带空格的一个字符串只会读空格前面的那部分)
// 故本题用gets()
//PS : gets可能不被PAT的编译器通过，故换成cin.getline也可以
//该题非自己全部想出来，故复习时需要完整捋一遍。
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111


using namespace std;
int main()
{
    char aim[1000], temp[1000];
    int n = 0, len, aimlen;
    gets(aim);
    aimlen = strlen(aim);
//    while(scanf("%s", lot[n]) != EOF){
//        n++;
//    }
//    printf("%d\n", n);
    while(gets(temp) != NULL){
        len = strlen(temp);
        for(int j = 0; j <len; j++){
            if(temp[j] == ' ') continue;
            if(temp[j] == aim[0] || fabs(temp[j] - aim[0]) == 32){
                int s = 0;
                for(int k = j; k <j + aimlen; k++){
                    if(temp[k] == aim[s] || fabs(temp[k] - aim[s]) == 32) s++;
                }
            if(s == aimlen) j = j + aimlen - 1;// s == aimlen 表示遇到了相等的字符串，直接跳过这个字符串
            else printf("%c", temp[j]); // 如果第一个相等但后边的不等
            }
            else printf("%c", temp[j]);
        }
        printf("\n");
    }


    return 0;
}

```


```C++
//问题 D: 单词替换
//复习字符串转移给二维数组那一段
//gets 与 scanf 最好不要在一个程序内一起用，要么都用gets要么都scanf
//字符串转移在字符串末尾必须加上'\0'，这道题是空格将长字符串分割成短字符串(也就是识别空格的位置来加'\0')
//但是，特别容易漏掉的地方，就是最后一个短字符串位于长字符串末尾没有空格，但是也别忘了加'\0'
//另外，该程序在n处未确定好具体是<n还是<=n，导致一直出错，但命令行还看不出迹象。
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111


using namespace std;
int main()
{
    char temp[101];
    while(gets(temp) != NULL){
        char ls[101][101];
        char rep[101],  aim[101];
        int n = 0, z = 0;
       for(int i=0;i<=strlen(temp); i++)
       {

           if(temp[i]!=' ')
               ls[n][z++] = temp[i];
           if(temp[i]==' '||i==strlen(temp))
           {
               ls[n][z]='\0';
               n++;
               z=0;
           }
       }
        gets(rep);
        gets(aim);
        for(int i = 0; i <n; i++){
            if(strcmp(ls[i], rep) == 0) printf("%s", aim);
            else printf("%s", ls[i]);
            if(i != n - 1) printf(" ");
            if(i == n - 1) printf("\n");
        }
    }
    return 0;
}

```

```C++
//编排字符串
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
const double eps = 1e-8;
const double odds = 0.65;
#define Equ(a, b) (fabs((a) - (b))<(eps))
#define Cpa(a, b) ((a) > (b))
#define maxn 1111


using namespace std;
int main()
{
    char ls[101][21];
    int N, n = 0, k = 0;
    scanf("%d", &N);
    while(N--){
        scanf("%s", ls[n++]);
        int x = 1;
        for(int i = k; i >=0; i--){
            printf("%d=%s", x, ls[i]);
            x++;
            if(x == 5) break;
            printf(" ");
        }
        k++;
        printf("\n");
    }

    return 0;
}
```
