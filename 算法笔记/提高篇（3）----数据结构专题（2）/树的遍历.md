# 第九章 提高篇（3）----数据结构专题（2）
## 9.3 树的遍历
本节内容是从之前的二叉树的遍历拓展到树的遍历，包括下面的先根、层序、DFS、BFS，的函数写法几乎与二叉树的一致

```C++
// example，都拿静态举例子
// 二叉树
void func(int root){
    if(root == -1) return;
    func(root.left);
    func(root.right);
}
```
```C++
// 常规树
// N:该结点的子结点数量
struct node {
    int weight, child_num, totwei;
    int child[maxn];//存储子结点的地址(下标)，存在多个子节点
}nodels[maxn];


void func(int root){
    if(root == -1) return;
    for(int i = 0; i < N, i++){
        func(nodels[root].child[i]);
    }
}
```
可以看到函数自身内部调用，二叉树2^n，普通树N^n，这里的N代表每个结点平均拥有的子节点个数
### 9.3.1 树的静态写法
### 9.3.2 树的先根遍历
### 9.3.3 树的层序遍历
### 9.3.4 从树的遍历看DFS与BFS
到这里从树的角度进一步加深了对DFS与BFS的理解，进而也像书上的猜想那样DFS、BFS问题应该大部分也可以用树的思想来解决。先根<=>DFS，层序<=>BFS

```C++
//1053 Path of Equal Weight (30 分)
//该题困惑在如何将递归过程的结果输出并实现排好顺序
//关于排序：可以实现对每个节点的子结点排好顺序(按weight)，也就是对结构体中的child[]数组排序，因为DFS中的for会对child[]依次进行遍历，child既然是有顺序的了，输出的结果自然也按照这个顺序
//关于输出每个结点的weight：可以事先在主程序中准备个int数组，将它放进DFS中的for循环里，遍历一个子节点就将该子节点的下标(地址)加入到int数组中，更新loc++，loc也要作为参数传入DFS中

//复习该题的上面两个点
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 110
using namespace std;
int N, M, S;

struct node {
    int weight, child_num, totwei;
    int child[maxn];
}nodels[maxn];

//vector<vector<int> > ls_tot;
stack<int> st;
int sum = 0, ls_tot[maxn];
void DFS(int root, int sum, int loc){
    if (sum > S) {
        return;
    }
    if (sum == S) {
        if (nodels[root].child_num != 0) {
            return;
        }
        else{
            for (int i = 0; i < loc; i++) {
                printf("%d", nodels[ls_tot[i]].weight);
                if (i < loc - 1) {
                    printf(" ");
                }
            }
            printf("\n");
            return;
        }
    }

    for (int i = 0; i < nodels[root].child_num; i++) {
        int kid = nodels[root].child[i];
        ls_tot[loc] = kid;
        DFS(kid, sum + nodels[kid].weight, loc + 1);
        
    }
}

bool cmp(int a, int b){
    return nodels[a].weight > nodels[b].weight;
}

int main(){
    scanf("%d %d %d", &N, &M, &S);
    for (int i = 0; i < N; i++) {
        scanf("%d", &nodels[i].weight);
        nodels[i].child_num = 0;
    }
    int loc, amount;
    for (int i = 0; i < M; i++) {
        scanf("%d %d", &loc, &amount);
        int temp = 0;
        for (int j = 0; j < amount; j++) {
            scanf("%d", &nodels[loc].child[temp++]);
        }
        if (temp) sort(nodels[loc].child, nodels[loc].child + temp, cmp);
        nodels[loc].child_num = temp;
    }
    ls_tot[0] = 0;
    DFS(0, nodels[0].weight, 1);

    
    return 0;
};

```

```C++
//1079 Total Sales of Supply Chain (25 分)
//题目中说结点数量最多有10^5个，所以结构体内部使用数组要开10^5大小存放，容易内存超限
//解决办法，结构体内部也可定义vector替代数组，而且如果要是数组的话，最好还是要初始化下数组，vector则不用
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 100010
using namespace std;
int N;
double P, r;

struct node{
    int child_amount;
    double amount, price;
    vector<int> child;
    //如果没有数组，初不初始化都可
    node(){
        child_amount = 0;
        amount = 0;
        price = 0;
    }
};
vector<node> ls;

void create(int root, double money){
    ls[root].price = money;
    if (ls[root].child_amount == 0) {
        return;
    }
    for (int i = 0; i < ls[root].child_amount; i++) {
        int new_root = ls[root].child[i];
        create(new_root, ls[root].price * (1.0 + 0.01 * r));
    }
}


int main(){

    scanf("%d %lf %lf", &N, &P, &r);
    int temp;
    for (int i = 0; i < N; i++) {
        scanf("%d", &temp);
        int ind = 0;
        node temp2;
        for (int j = 0; j < temp; j++) {
            int vec_temp;
            scanf("%d", &vec_temp);
            temp2.child.push_back(vec_temp);
        }
        temp2.child_amount = (int)temp2.child.size();
        temp2.price = P;
        if (temp == 0) {
            scanf("%lf", &temp2.amount);
        }
        ls.push_back(temp2);
    }
    create(0, P);

    double tot = 0;
    for (int i = 0; i < N; i++) {
        if (ls[i].child_amount == 0) {
            tot += ls[i].price * ls[i].amount;
        }
    }
    printf("%.1lf", tot);

    
    return 0;
};


```
