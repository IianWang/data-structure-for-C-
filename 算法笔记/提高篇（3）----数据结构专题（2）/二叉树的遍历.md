# 第九章 提高篇（3）----数据结构专题（2）
## 9.2 二叉树的遍历
### 9.2.1 先序遍历（perorder）
### 9.2.2 中序遍历（inorder）
### 9.2.3 后序遍历（postorder）
### 9.2.4 层序遍历
### 9.2.5 二叉树的静态实现

```C++
//1020 Tree Traversals (25 分)
//两个考察点
//1. 通过后序遍历与中序遍历获得原二叉树
//2. 将原二叉树按层序遍历方式输出

//复习重点：create函数内部调用的传参，postL，postR，inL，inR 的值如何确定，以及和前序+中序的create函数区分

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 10100
using namespace std;
int post[31], in[31];
int N;

struct node{
    int data;
    int layer; //记录该节点所在层次
    node* lchild;
    node* rchild;
};

node* create(int preL, int preR, int inL, int inR){
    if (preR < preL) {
        return NULL;
    }
    node* root = new node;
    root -> data =  post[preR];
    int k;
    for (k = 0; k < inR; k++) {
        if (post[preR] == in[k]) break;
    }
    int numleft = k - inL;
    root -> lchild = create(preL, preL + numleft - 1, inL, inL + numleft - 1);
    root -> rchild =  create(preL + numleft, preR - 1, inL + numleft + 1, inR);
    return root;
}

queue<int> val;
void BFS(node* root){
    int num = 0;
    queue<node*> qu;
    qu.push(root);
    while (!qu.empty()) {
        num++;
        node* temp = qu.front();
        printf("%d", temp -> data);
        if (num < N) {
            printf(" ");
        }
        qu.pop();
        if (temp -> lchild != NULL) {
            qu.push(temp -> lchild);
        }
        if (temp -> rchild != NULL) {
            qu.push(temp -> rchild);
        }
    }
}

int main(){
    
    scanf("%d", &N);
    for(int i = 0; i < N; i++){
        scanf("%d", &post[i]);
    }
    for(int k = 0; k < N; k++) scanf("%d", &in[k]);
    
    node* root = create(0, N - 1, 0, N - 1);
    BFS(root);

    return 0;
};
```
