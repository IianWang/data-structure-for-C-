# 第九章 提高篇（3）----数据结构专题（2）
## 9.2 二叉树的遍历
### 9.2.1 先序遍历（perorder）
### 9.2.2 中序遍历（inorder）
### 9.2.3 后序遍历（postorder）
### 9.2.4 层序遍历
### 9.2.5 二叉树的静态实现

```C++
//1020 Tree Traversals (25 分)
//两个考察点
//1. 通过后序遍历与中序遍历获得原二叉树
//2. 将原二叉树按层序遍历方式输出

//复习重点：create函数内部调用的传参，postL，postR，inL，inR 的值如何确定，以及和前序+中序的create函数区分

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 10100
using namespace std;
int post[31], in[31];
int N;

struct node{
    int data;
    int layer; //记录该节点所在层次
    node* lchild;
    node* rchild;
};

node* create(int preL, int preR, int inL, int inR){
    if (preR < preL) {
        return NULL;
    }
    node* root = new node;
    root -> data =  post[preR];
    int k;
    for (k = 0; k < inR; k++) {
        if (post[preR] == in[k]) break;
    }
    int numleft = k - inL;
    root -> lchild = create(preL, preL + numleft - 1, inL, inL + numleft - 1);
    root -> rchild =  create(preL + numleft, preR - 1, inL + numleft + 1, inR);
    return root;
}

queue<int> val;
void BFS(node* root){
    int num = 0;
    queue<node*> qu;
    qu.push(root);
    while (!qu.empty()) {
        num++;
        node* temp = qu.front();
        printf("%d", temp -> data);
        if (num < N) {
            printf(" ");
        }
        qu.pop();
        if (temp -> lchild != NULL) {
            qu.push(temp -> lchild);
        }
        if (temp -> rchild != NULL) {
            qu.push(temp -> rchild);
        }
    }
}

int main(){
    
    scanf("%d", &N);
    for(int i = 0; i < N; i++){
        scanf("%d", &post[i]);
    }
    for(int k = 0; k < N; k++) scanf("%d", &in[k]);
    
    node* root = create(0, N - 1, 0, N - 1);
    BFS(root);

    return 0;
};
```

```C++
//1086 Tree Traversals Again (25 分)
//和上一道题如出一辙
//两个考察点
//1. 通过前序遍历与中序遍历获得原二叉树
//2. 将原二叉树按后序遍历方式输出（后序输出过程中注意num++摆放的位置）

//
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 10100
using namespace std;
int in[30], pre[30], ind_pre = 0, ind_in = 0, num = 0, N;

struct node{
    int data;
    int layer; //记录该节点所在层次
    node* lchild;
    node* rchild;
};

node* create(int preL, int preR, int inL, int inR){
    if (preR < preL) {
        return NULL;
    }
    node* root = new node;
    root -> data = pre[preL];
    int k;
    for (k = inL ; k < inR; k++) {
        if (in[k] == pre[preL]) {
            break;
        }
    }
    int numleft = k - inL;
    root -> lchild = create(preL + 1, preL + numleft, inL, inL + numleft - 1);
    root -> rchild = create(preL + numleft + 1, preR, inL + numleft + 1, inR);
    return root;
}

void postprint(node* root){
    if (root == NULL) {
        return;
    }
    
    postprint(root -> lchild);
    postprint(root -> rchild);
    printf("%d", root -> data);
    num++;
    if (num < N) {
        printf(" ");
    }
}

int main(){
    stack<int> temp;
    char opera[5];
    scanf("%d", &N);
    for (int i = 0; i < 2 * N; i++) {
        scanf("%s", opera);
        if (strcmp(opera, "Push") == 0) {
            scanf("%d", &pre[ind_pre++]);
            temp.push(pre[ind_pre - 1]);
        }
        else{
            in[ind_in++] = temp.top();
            temp.pop();
        }
    }
    for (int i = 0; i < N; i++) {
        printf("%d %d\n", in[i], pre[i]);
    }
    node* root = create(0, N - 1, 0, N - 1);
//    printf("%d %d\n", root -> lchild -> data, root -> rchild -> data);
    postprint(root);

    return 0;
};
```
