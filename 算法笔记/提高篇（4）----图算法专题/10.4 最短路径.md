# 第九章 提高篇（4）----图算法专题
## 10.4 最短路径
### 10.4.1 Dijkstra 算法

```C++
const int INF = 100000000;
int ls[maxn][maxn], d[maxn], N; //ls矩阵存储点与点之间的"距离"，初始化为INF（也就是假设出发地和任何一个点都是不通的，根据输入，令对应的矩阵位置为输入的信息，表明是x,y之间是通的）
bool hashls[maxn] = {false};//不仅仅是防止回头路这么简单了，因为每次到达一条路的终点后要返回始发地，这个时候不能再走重复路了

void Dijkstra(int root){
    fill(d, d + maxn, INF);//将d(记录始发地到i(下标)之间的最短距离为d[i]，初始化为极大，在满足条件时更新)
    d[root] = 0;//初始化始发地到始发地之间的距离为0，内循环也从始发地开始，这个常规认知有点差异，不过不影响
    for (int i = 0; i < N; i++) {//整个大循环包括下面的所有，这里就是每次一回合结束，又会回到起点走没走的路
        int MIN = INF, u = -1;//重要！设置比较变量，根据下面的内循环选出离当前最近的结点，优先走
        for (int j = 0; j < N; j++) {
            if (hashls[j] == false && d[j] < MIN) {//这里就是设置了不能走重复的路了且还得能看的到路，因为d[]除了d[0]以外都是INF，所以第一次就是d[0]，d[x]会在else循环里更新
                MIN = d[j];//更新距离下限
                u = j;//选出最近的点
            }
        }
        if (u == -1) return;//说明上面那个内循环没走，也就是说没有新路可走了，那么结束跳出
        else{
            hashls[u] = true;
            for (int k = 0; k < N; k++) {//这个for循环一次性把该结点连接的下一层的结点的距离都更新了，有点BFS的味道了，只不过用的是循环实现
                if (hashls[k] == false && ls[u][k] != INF && d[u] + ls[u][k] < d[k]) {//这里也是极为重要，考试花样可能在这里
                //三个条件，既得满足这个路存在也得是没走过的分支走过的路程还要小于预设的值（当然在预设INF更新后，新值如果满足还会再更新）
                    d[k] = d[u] + ls[u][k];//d[]存储更新的最短路径，下标及对应的地点序号，（也就是说该地点存的是从始发地到它这里的路径）
                }
            }
        }
    }
}
```
