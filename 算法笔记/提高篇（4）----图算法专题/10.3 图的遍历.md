# 第九章 提高篇（4）----图算法专题
## 10.3 图的遍历
### 10.3.1 采用深度优先搜索（DFS）法遍历图
- 用DFS遍历图
- DFS的具体实现

```C++
//1034 Head of a Gang (30 分)
//比较灵活的一道题，套路的基础上多变，也是心态爆炸的一道题，花费了近3个小时，总的说来还是对图的存储与遍历搞不清
//复习

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 2010
using namespace std;
map<string, int> strToInt;
map<int, string> intToStr;
map<string, int> gang;
int vis[maxn] = {false};
int ls_weight[maxn] = {0};
int hashVal = 0;
int G[maxn][maxn] = {0};
int N, K;

int iscontain(string str){
    if (strToInt.find(str) != strToInt.end()) {
        return strToInt[str];
    }
    else{
        strToInt[str] = hashVal;
        intToStr[hashVal] = str;
        return hashVal++;
    }
}

void DFS(int n, int &totvalue, int &member, int &head){
    member++;//更新成员个数
    vis[n] = true;
    if (ls_weight[n] > ls_weight[head]) {
        head = n; //更新这一组点权最大的
    }
    for (int i = 0; i < hashVal; i++) {
        if (G[n][i] > 0) {
            totvalue += G[n][i]; //更新总边权
            G[n][i] = G[i][n] = 0;//删除这条边，防止回头，无向图矩阵故为对称
            if (vis[i] == false) {
                DFS(i, totvalue, member, head);
            }
        }
    }
}

void traDFS(){
    for (int i = 0; i < hashVal; i++) {
        if (vis[i] == false) {
            int totvalue = 0, member = 0, head = i;
            DFS(i, totvalue, member, head);
            if (member > 2 && totvalue > K) {
                gang[intToStr[head]] = member;
            }
        }
    }
}

int main(){
    
    scanf("%d %d", &N, &K);
    string str1, str2;
    int W, loc1, loc2;
    for (int i = 0; i < N; i++) {
        cin >> str1 >> str2 >> W;
        loc1 = iscontain(str1);
        loc2 = iscontain(str2);
        ls_weight[loc1] += W;
        ls_weight[loc2] += W;
        G[loc1][loc2] = W;
        G[loc2][loc1] = W;
    }
    traDFS();
    map<string, int>::iterator it;
    printf("%d\n", (int)gang.size());
    for (it = gang.begin(); it != gang.end(); it++) {
        printf("%s %d\n", (it -> first).c_str(), it -> second);
    }

    return 0;
};

```

```C++
//1076 Forwards on Weibo (30 分)
//数组矩阵 + BFS解决问题，但是有几个点需要特别注意。
//1. 图的BFS虽然遵循树BFS常用的固定模式，但多多少少还有多点点不同，就是图的遍历（特别是数组矩阵），多了一个bool hash[]数组，
//bool hash[]防止入过队列的元素被其它元素再次索引到，导致再次入队每当进入队列一个元素，该元素在bool hashls对应位置一定要设置为true，表示已经入过了，如果有后面有重复的也就不再计数了。
//2. 你像这道题，编号是从1 - N，题中有说，所以数组矩阵直接就是按1 - N来，省默认0开始，后面乱套了又不知道问题在哪
//对于循环使用BFS的，队列要初始化在BFS函数里
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 2010
using namespace std;
int ls[maxn][maxn] = {0}, N, levl;
bool vis[maxn] = {false};
struct node{
    int user_num;
    int level;
};


int BFS(node first){
    queue<node> qu;
    int amount = 0;
    vis[first.user_num] = true;
    qu.push(first);
    while (!qu.empty()) {
        int level_new = 0;
        bool flag = true;
        node temp = qu.front();
        qu.pop();
        for (int i = 1; i <= N; i++) {
            if (ls[i][temp.user_num] == 1 && vis[i] == false) {
                if (flag) {
                    flag = false;
                    level_new = temp.level + 1;
                }
                amount++;
                vis[i] = true;
                node new_temp;
                new_temp.user_num = i;
                new_temp.level = level_new;
                qu.push(new_temp);
            }
        }
        if (qu.front().level == levl) {
            break;
        }
    }
    return amount;
}

int main(){
    scanf("%d %d", &N, &levl);
    int counts, flw;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &counts);
        for (int j = 0; j < counts; j++) {
            scanf("%d", &flw);
            ls[i][flw] = 1;
        }
    }
    
    int query, user;
    scanf("%d", &query);
    for (int i = 0; i < query; i++) {
        scanf("%d", &user);
        node first;
        first.user_num = user;
        first.level = 0;
        printf("%d\n", BFS(first));
        for (int j = 0; j < maxn; j++) {
            vis[j] = false;
        }
    }

    return 0;
};

```
