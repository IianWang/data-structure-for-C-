# 第九章 提高篇（4）----图算法专题
## 10.3 图的遍历
### 10.3.1 采用深度优先搜索（DFS）法遍历图
- 用DFS遍历图
- DFS的具体实现

```C++
//1034 Head of a Gang (30 分)
//比较灵活的一道题，套路的基础上多变，也是心态爆炸的一道题，花费了近3个小时，总的说来还是对图的存储与遍历搞不清
//复习

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#define maxn 2010
using namespace std;
map<string, int> strToInt;
map<int, string> intToStr;
map<string, int> gang;
int vis[maxn] = {false};
int ls_weight[maxn] = {0};
int hashVal = 0;
int G[maxn][maxn] = {0};
int N, K;

int iscontain(string str){
    if (strToInt.find(str) != strToInt.end()) {
        return strToInt[str];
    }
    else{
        strToInt[str] = hashVal;
        intToStr[hashVal] = str;
        return hashVal++;
    }
}

void DFS(int n, int &totvalue, int &member, int &head){
    member++;//更新成员个数
    vis[n] = true;
    if (ls_weight[n] > ls_weight[head]) {
        head = n; //更新这一组点权最大的
    }
    for (int i = 0; i < hashVal; i++) {
        if (G[n][i] > 0) {
            totvalue += G[n][i]; //更新总边权
            G[n][i] = G[i][n] = 0;//删除这条边，防止回头，无向图矩阵故为对称
            if (vis[i] == false) {
                DFS(i, totvalue, member, head);
            }
        }
    }
}

void traDFS(){
    for (int i = 0; i < hashVal; i++) {
        if (vis[i] == false) {
            int totvalue = 0, member = 0, head = i;
            DFS(i, totvalue, member, head);
            if (member > 2 && totvalue > K) {
                gang[intToStr[head]] = member;
            }
        }
    }
}

int main(){
    
    scanf("%d %d", &N, &K);
    string str1, str2;
    int W, loc1, loc2;
    for (int i = 0; i < N; i++) {
        cin >> str1 >> str2 >> W;
        loc1 = iscontain(str1);
        loc2 = iscontain(str2);
        ls_weight[loc1] += W;
        ls_weight[loc2] += W;
        G[loc1][loc2] = W;
        G[loc2][loc1] = W;
    }
    traDFS();
    map<string, int>::iterator it;
    printf("%d\n", (int)gang.size());
    for (it = gang.begin(); it != gang.end(); it++) {
        printf("%s %d\n", (it -> first).c_str(), it -> second);
    }

    return 0;
};

```
